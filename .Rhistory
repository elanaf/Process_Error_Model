r22 = cfs_mp[22], r23 = cfs_mp[23], r24 = cfs_mp[24],
r25 = cfs_mp[25], r26 = cfs_mp[26], r27 = cfs_mp[27],
r28 = cfs_mp[28], r29 = cfs_mp[29], r30 = cfs_mp[30],
r31 = cfs_mp[31], r32 = cfs_mp[32], r33 = cfs_mp[33],
r34 = cfs_mp[34], r35 = cfs_mp[35], r36 = cfs_mp[36],
n0 = cfs_mp[37], obs = native.mat, species.vec = species.vec)
plot(native.mat, pred_mp, xlab = "Observed", ylab = "Predicted",pch = 16, las = 1, ylim = c(0,1))
abline(0, 1) # Add 1:1 line on figure indicating perfect fit
summary(lm(as.vector(native.mat) ~ as.vector(pred_mp)))
as.vector(native.mat)
as.vector(pred_mp)
####now try all w, both h and l####
####################################################
#Graph the species to determine that they are following logistic growth
####################################################
load("main_dfs.RData")
library(ggplot2)
library(magrittr)
library(dplyr)
library(gtools)
####################################################
# Make a new dataframe that is in a better format
####################################################
#only select columns that I need for the analysis
native.dat <- greenhouse %>%
filter(Species != "PHAU") %>%
filter(Phrag_Presence == "W")%>%
select(Species, Block, Density, Phrag_Presence, Date_Cleaned, Cover.Native)  %>%
arrange(Species,Density) #put same species next to each other
#but I have to change the name of the extra BICE
native.dat$Block <- as.numeric(native.dat$Block)
native.dat[3,2] <- 4
native.dat[7,2] <- 4
native.dat[11,2] <- 4
native.dat[15,2] <- 4
native.dat$ID_Col <- with(native.dat, paste0(Species, Block, Density))
#make vectors to keep track of the species
#I need to do the numbers differently here because BICE has 16 and SCAM has 8
table(native.dat$Species, native.dat$Density)
species.vec1 <- rep(1, 16)
species.vec2 <- rep(2:28, each = 12)
species.vec3 <- rep(29, 8)
species.vec4 <- rep(30:36, each = 12)
species.vec <- c(species.vec1, species.vec2, species.vec3, species.vec4)
#rearrange so date is column
native.dat <- reshape2::dcast(native.dat, ID_Col ~ Date_Cleaned, value.var = "Cover.Native")
#now make a matrix
native.mat <- as.matrix(native.dat[,-1]) #make it a matrix, without the ID_Col
native.mat[is.na(native.mat)] <- 0 #make all NAs 0
native.mat[native.mat == 0] <- 0.025 #get rid of 0s
#add the extra days so that it becomes a daily timestep
first <- matrix(NA, nrow = 108, ncol=17)
second <- matrix(native.mat[,1])
third <- matrix(NA, nrow = 108, ncol = 6)
fourth <- matrix(native.mat[,2])
fifth <- matrix(NA, nrow = 108, ncol = 6)
sixth <- matrix(native.mat[,3])
seventh <- matrix(NA, nrow = 108, ncol = 6)
eighth <- matrix(native.mat[,4])
native.mat <- cbind(first, second, third, fourth, fifth, sixth, seventh, eighth)
#predict the mean (expected value) of every timestep when you don't have an observation- see below
#Multi process error
multi.func.p<-function(r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11,
r12, r13, r14, r15, r16, r17, r18,
r19, r20, r21, r22, r23, r24, r25,
r26, r27, r28, r29,
r30, r31, r32, r33, r34, r35, r36,
obs,n0, species.vec){
rvec <- c(r1, r2, r3, r4, r5, r6, r7, r8, r9, r10,
r11, r12, r13, r14, r15, r16, r17, r18,
r19, r20, r21, r22, r23, r24, r25,
r26, r27, r28, r29,
r30, r31, r32, r33, r34, r35, r36)
dims <- dim(obs)
ntubs <- dims[1]
ts <- dims[2]
Nout <- matrix(0, nrow = ntubs, ncol = ts)
for(i in 1:ntubs){
Nout[i,1]<-n0*(1+rvec[species.vec[i]]*(1-n0/.995))
}
for(i in 2:ts){
for(j in 1:ntubs){
if(!is.na(obs[j, i-1])) {
Nout[j, i]<-obs[j, i-1]*(1+rvec[species.vec[j]]*(1-obs[j, i-1]/.995))
}
if(is.na(obs[j, i-1])){ #if it is an NA, do off the last predicted
Nout[j, i] <- Nout[j, i-1]*(1+rvec[species.vec[j]]*(1-Nout[j, i-1]/.995))
}
}
}
return(Nout)
}
#test
multi.func.p(r1 = .7, r2 = .9, r3 = .9, r4 = .7, r5 = .9, r6 = .2, r7 = .7, r8 = .6,
r9 = .9, r10 = .1, r11 = .1,
r12 = .1, r13 = .1, r14 = .1, r15 = .1, r16 = .1, r17 = .1, r18 = .1,
r19 =.1, r20=.1, r21=.1,
r22=.1, r23=.1, r24=.1, r25=.1,
r26=.1, r27=.1, r28=.1, r29=.1,
r30=.1, r31=.1, r32=.1, r33=.1, r34=.1, r35=.1, r36=.1,
species.vec = species.vec,
obs = native.mat, n0 = .1)
#Multi process error - for the process error model, I just need to predict a number based on the previous timstep
#I would calculate the timestep between recorded values similar to how we did with the spatial models
#then the mean is your last observed value
#variance is the variance of the last timestepx the number of time steps because the variance increases linearly with the number of timesteps out
#tbefore putting it into dnorm, you calculate the sd from the variance (sqrt(timesteps x variance))
#qlogis of the predicted N
nll.multi.func.p<-function(lr1, lr2, lr3, lr4, lr5, lr6, lr7, lr8, lr9,
lr10, lr11, lr12, lr13, lr14, lr15, lr16, lr17, lr18,
lr19, lr20, lr21, lr22, lr23, lr24, lr25, lr26, lr27,
lr28, lr29, lr30, lr31, lr32, lr33, lr34, lr35, lr36,
species.vec,
obs,ln0, lsd){
r1<-exp(lr1)
r2<-exp(lr2)
r3<-exp(lr3)
r4<-exp(lr4)
r5 <- exp(lr5)
r6 <- exp(lr6)
r7 <- exp(lr7)
r8 <- exp(lr8)
r9 <- exp(lr9)
r10 <- exp(lr10)
r11 <- exp(lr11)
r12 <- exp(lr12)
r13 <- exp(lr13)
r14 <- exp(lr14)
r15 <- exp(lr15)
r16 <- exp(lr16)
r17 <- exp(lr17)
r18 <- exp(lr18)
r19 <- exp(lr19)
r20 <- exp(lr20)
r21 <- exp(lr21)
r22 <- exp(lr22)
r23 <- exp(lr23)
r24 <- exp(lr24)
r25 <- exp(lr25)
r26 <- exp(lr26)
r27 <- exp(lr27)
r28 <- exp(lr28)
r29 <- exp(lr29)
r30 <- exp(lr30)
r31 <- exp(lr31)
r32 <- exp(lr32)
r33 <- exp(lr33)
r34 <- exp(lr34)
r35 <- exp(lr35)
r36 <- exp(lr36)
s <-exp(lsd)
n0 <- exp(ln0)
predN<-multi.func.p(r1=r1,r2=r2,r3=r3,r4=r4,r5=r5,r6=r6, r7=r7,r8=r8,
r9=r9, r10=r10,r11=r11, r12=r12, r13=r13, r14=r14,
r15=r15, r16=r16, r17=r17, r18=r18, r19=r19, r20=r20,
r21=r21,
r22=r22, r23=r23, r24=r24, r25=r25,r26=r26,
r27=r27, r28=r28, r29=r29, r30=r30, r31=r31, r32=r32,
r33=r33, r34=r34, r35=r35, r36=r36,
obs=obs,species.vec = species.vec, n0 = n0)
# obs2 <- obs[!is.na(obs)]
# predN2 <- predN[!is.na(obs)]
# param <- dampack::beta_params(mean = predN2, sigma = sd)
# alpha <- param[1]
# alpha <- unlist(alpha)
# beta <- param[2]
# beta <- unlist(beta)
predN[predN==0]<-.01
predN[predN==1]<-.99
# print(obs)
# print(predN)
liks<-0
for(j in 1:nrow(obs)){
lastobs <- 0
for(i in 1:ncol(obs)){
if(!is.na(obs[j, i])){
tbtwn<-i-lastobs
# print(tbtwn)
liks<-c(liks, dnorm(x=qlogis(obs[j, i]),mean=qlogis(predN[j, i]),sd=sqrt(tbtwn*s^2)))
lastobs<-i
# print(liks)
}
}
}
# likes <- dbeta(x=obs2,shape1 = alpha, shape2 = beta)
# likes <- dnorm(x=qlogis(obs2), mean=plogis(predN2), sd = sd)
nll<--1*sum(log(liks[-1]))
return(nll)
}
#test
nll.multi.func.p(lr1 = log(.4), lr2 = log(.4),lr3 = log(.4),
lr4 = log(.4),lr5 = log(.4),lr6 = log(.4),
lr7 = log(.4),lr8 = log(.4),lr9 = log(.4), lr10 = log(.4),
lr11 = log(.4), lr12 = log(.4), lr13 = log(.4), lr14 = log(.4), lr15 = log(.4),
lr16 = log(.4), lr17 = log(.4), lr18 = log(.4), lr19 = log(.4),
lr20 = log(.4), lr21 = log(.4),
lr22 = log(.4), lr23 = log(.4),
lr24 = log(.4), lr25 = log(.4),
lr26 = log(.4), lr27 = log(.4),
lr28 = log(.4), lr29 = log(.4), lr30 = log(.4), lr31 = log(.4),
lr32 = log(.4), lr33 = log(.4), lr34 = log(.4), lr35 = log(.4),
lr36 = log(.4),
ln0 = log(.01), obs = native.mat, lsd = log(.05), species.vec = species.vec)
library(bbmle)
# Create list of starting guesses for the multi model
start.list<-list(lr1=log(.1),
lr2 = log(.2),
lr3 = log(.1),
lr4 = log(.1),
lr5=log(.2),
lr6 = log(.1),
lr7 = log(.1),
lr8 = log(.1),
lr9 = log(.1),
lr10 = log(.1),
lr11 = log(.1),
lr12 = log(.1),
lr13 = log(.1),
lr14 = log(.1),
lr15 = log(.1),
lr16 = log(.1),
lr17 = log(.1),
lr18 = log(.1),
lr19 = log(.1),
lr20 = log(.1),
lr21 = log(.1),
lr22 = log(.1),
lr23 = log(.1),
lr24 = log(.1),
lr25 = log(.1),
lr26 = log(.1),
lr27 = log(.1),
lr28 = log(.1),
lr29 = log(.1),
lr30 = log(.1),
lr31 = log(.1),
lr32 = log(.1),
lr33 = log(.1),
lr34 = log(.1),
lr35 = log(.1),
lr36 = log(.1),
lsd = log(.05),
ln0 = log(0.0001))
# Create list of observed data for model
data.list<-list(obs=native.mat, species.vec = species.vec, method = "SANN")
# # Find MLE parameter estimates
fit_mp<-mle2(minuslogl=nll.multi.func.p,start=start.list,data=data.list, method = "SANN")
# # store MLE parameter estimates
cfs_mp<-exp(coef(fit_mp))
cfs_mp
pred_mp<-multi.func.p(r1 = cfs_mp[1], r2 = cfs_mp[2], r3 = cfs_mp[3],
r4 = cfs_mp[4], r5 = cfs_mp[5], r6 = cfs_mp[6],
r7 = cfs_mp[7], r8 = cfs_mp[8], r9 = cfs_mp[9],
r10 = cfs_mp[10], r11 = cfs_mp[11], r12 = cfs_mp[12],
r13 = cfs_mp[13], r14 = cfs_mp[14], r15 = cfs_mp[15],
r16 = cfs_mp[16], r17 = cfs_mp[17], r18 = cfs_mp[18],
r19 = cfs_mp[19], r20 = cfs_mp[20], r21 = cfs_mp[21],
r22 = cfs_mp[22], r23 = cfs_mp[23], r24 = cfs_mp[24],
r25 = cfs_mp[25], r26 = cfs_mp[26], r27 = cfs_mp[27],
r28 = cfs_mp[28], r29 = cfs_mp[29], r30 = cfs_mp[30],
r31 = cfs_mp[31], r32 = cfs_mp[32], r33 = cfs_mp[33],
r34 = cfs_mp[34], r35 = cfs_mp[35], r36 = cfs_mp[36],
n0 = cfs_mp[37], obs = native.mat, species.vec = species.vec)
plot(native.mat, pred_mp, xlab = "Observed", ylab = "Predicted",pch = 16, las = 1, ylim = c(0,1))
abline(0, 1) # Add 1:1 line on figure indicating perfect fit
summary(lm(as.vector(native.mat) ~ as.vector(pred_mp)))
####################################################
# Make a new dataframe that is in a better format
####################################################
#only select columns that I need for the analysis
native.dat <- greenhouse %>%
filter(Species != "PHAU") %>%
select(Species, Block, Density, Phrag_Presence, Date_Cleaned, Cover.Native)  %>%
arrange(Species,Density, Phrag_Presence) #put same species next to each other
#but I have to change the name of the extra BICE and SCAM
native.dat$Block <- as.numeric(native.dat$Block)
table(native.dat$Species, native.dat$Density, native.dat$Phrag_Presence)
native.dat[3,2] <- 4
native.dat[7,2] <- 4
native.dat[11,2] <- 4
native.dat[15,2] <- 4
native.dat[683, 2] <- 4
native.dat[687, 2] <- 4
native.dat[691, 2] <- 4
native.dat[695, 2] <- 4
native.dat$ID_Col <- with(native.dat, paste0(Species, Block, Density, Phrag_Presence))
#make vectors to keep track of the species
#I need to do the numbers differently here because BICE has 16 and SCAM has 8
table(native.dat$Species, native.dat$Density, native.dat$Phrag_Presence)
#species go hw, hwo, lw, lwo
species.vec1 <- rep(1, 16)
species.vec2 <- rep(2, 12)
species.vec3 <- rep(3, 8)
species.vec4 <- rep(4:56, each = 12)
species.vec5 <- rep(57, 8)
species.vec6 <- rep(58, 12)
species.vec7 <- rep(59, 16)
species.vec8 <- rep(60:72, each = 12)
species.vec <- c(species.vec1, species.vec2, species.vec3, species.vec4,
species.vec5, species.vec6, species.vec7, species.vec8)
#rearrange so date is column
native.dat <- reshape2::dcast(native.dat, ID_Col ~ Date_Cleaned, value.var = "Cover.Native")
#now make a matrix
native.mat <- as.matrix(native.dat[,-1]) #make it a matrix, without the ID_Col
native.mat[is.na(native.mat)] <- 0 #make all NAs 0
native.mat[native.mat == 0] <- 0.025 #get rid of 0s
#add the extra days so that it becomes a daily timestep
first <- matrix(NA, nrow = 216, ncol=17)
second <- matrix(native.mat[,1])
third <- matrix(NA, nrow = 216, ncol = 6)
fourth <- matrix(native.mat[,2])
fifth <- matrix(NA, nrow = 216, ncol = 6)
sixth <- matrix(native.mat[,3])
seventh <- matrix(NA, nrow = 216, ncol = 6)
eighth <- matrix(native.mat[,4])
native.mat <- cbind(first, second, third, fourth, fifth, sixth, seventh, eighth)
#predict the mean (expected value) of every timestep when you don't have an observation- see below
#Multi process error
multi.func.p<-function(r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11,
r12, r13, r14, r15, r16, r17, r18,
r19, r20, r21, r22, r23, r24, r25,
r26, r27, r28, r29, r30, r31, r32, r33, r34, r35, r36,
r37, r38, r39, r40, r41, r42, r43, r44, r45, r46, r47,
r48, r49, r50, r51, r52, r53, r54,
r55, r56, r57, r58, r59, r60, r61,
r62, r63, r64, r65, r66, r67, r68, r69, r70, r71, r72,
obs,n0, species.vec){
rvec <- c(r1, r2, r3, r4, r5, r6, r7, r8, r9, r10,
r11, r12, r13, r14, r15, r16, r17, r18,
r19, r20, r21, r22, r23, r24, r25, r26, r27, r28,
r29, r30, r31, r32, r33, r34, r35, r36,
r37, r38, r39, r40, r41, r42, r43, r44, r45, r46, r47,
r48, r49, r50, r51, r52, r53, r54,
r55, r56, r57, r58, r59, r60, r61,
r62, r63, r64, r65, r66, r67, r68, r69, r70, r71, r72)
dims <- dim(obs)
ntubs <- dims[1]
ts <- dims[2]
Nout <- matrix(0, nrow = ntubs, ncol = ts)
for(i in 1:ntubs){
Nout[i,1]<-n0*(1+rvec[species.vec[i]]*(1-n0/.995))
}
for(i in 2:ts){
for(j in 1:ntubs){
if(!is.na(obs[j, i-1])) {
Nout[j, i]<-obs[j, i-1]*(1+rvec[species.vec[j]]*(1-obs[j, i-1]/.995))
}
if(is.na(obs[j, i-1])){ #if it is an NA, do off the last predicted
Nout[j, i] <- Nout[j, i-1]*(1+rvec[species.vec[j]]*(1-Nout[j, i-1]/.995))
}
}
}
return(Nout)
}
#test
multi.func.p(r1 = .7, r2 = .9, r3 = .9, r4 = .7, r5 = .9, r6 = .2, r7 = .7, r8 = .6,
r9 = .9, r10 = .1, r11 = .1,
r12 = .1, r13 = .1, r14 = .1, r15 = .1, r16 = .1, r17 = .1, r18 = .1,
r19 =.1, r20=.1, r21=.1,
r22=.1, r23=.1, r24=.1, r25=.1,
r26=.1, r27=.1, r28=.1, r29=.1,
r30=.1, r31=.1, r32=.1, r33=.1, r34=.1, r35=.1, r36=.1,
r37=.1, r38=.1, r39=.1, r40=.1, r41=.1, r42=.1, r43=.1, r44=.1,
r45=.1, r46=.1, r47=.1,
r48=.1, r49=.1, r50=.1, r51=.1, r52=.1, r53=.1, r54=.1,
r55=.1, r56=.1, r57=.1, r58=.1, r59=.1, r60=.1, r61=.1,
r62=.1, r63=.1, r64=.1, r65=.1, r66=.1, r67=.1, r68=.1,
r69=.1, r70=.1, r71=.1, r72=.1,
species.vec = species.vec,
obs = native.mat, n0 = .1)
#Multi process error - for the process error model, I just need to predict a number based on the previous timstep
#I would calculate the timestep between recorded values similar to how we did with the spatial models
#then the mean is your last observed value
#variance is the variance of the last timestepx the number of time steps because the variance increases linearly with the number of timesteps out
#tbefore putting it into dnorm, you calculate the sd from the variance (sqrt(timesteps x variance))
#qlogis of the predicted N
nll.multi.func.p<-function(lr1, lr2, lr3, lr4, lr5, lr6, lr7, lr8, lr9,
lr10, lr11, lr12, lr13, lr14, lr15, lr16, lr17, lr18,
lr19, lr20, lr21, lr22, lr23, lr24, lr25, lr26, lr27,
lr28, lr29, lr30, lr31, lr32, lr33, lr34, lr35, lr36,
lr37, lr38, lr39, lr40, lr41, lr42, lr43, lr44, lr45,
lr46, lr47, lr48, lr49, lr50, lr51, lr52, lr53, lr54,
lr55, lr56, lr57, lr58, lr59, lr60, lr61, lr62, lr63,
lr64, lr65, lr66, lr67, lr68, lr69, lr70, lr71, lr72,
species.vec,
obs,ln0, lsd){
r1<-exp(lr1)
r2<-exp(lr2)
r3<-exp(lr3)
r4<-exp(lr4)
r5 <- exp(lr5)
r6 <- exp(lr6)
r7 <- exp(lr7)
r8 <- exp(lr8)
r9 <- exp(lr9)
r10 <- exp(lr10)
r11 <- exp(lr11)
r12 <- exp(lr12)
r13 <- exp(lr13)
r14 <- exp(lr14)
r15 <- exp(lr15)
r16 <- exp(lr16)
r17 <- exp(lr17)
r18 <- exp(lr18)
r19 <- exp(lr19)
r20 <- exp(lr20)
r21 <- exp(lr21)
r22 <- exp(lr22)
r23 <- exp(lr23)
r24 <- exp(lr24)
r25 <- exp(lr25)
r26 <- exp(lr26)
r27 <- exp(lr27)
r28 <- exp(lr28)
r29 <- exp(lr29)
r30 <- exp(lr30)
r31 <- exp(lr31)
r32 <- exp(lr32)
r33 <- exp(lr33)
r34 <- exp(lr34)
r35 <- exp(lr35)
r36 <- exp(lr36)
r37<-exp(lr37)
r38<-exp(lr38)
r39<-exp(lr39)
r40<-exp(lr40)
r41 <- exp(lr41)
r42 <- exp(lr42)
r43 <- exp(lr43)
r44 <- exp(lr44)
r45 <- exp(lr45)
r46 <- exp(lr46)
r47 <- exp(lr47)
r48 <- exp(lr48)
r49 <- exp(lr49)
r50 <- exp(lr50)
r51 <- exp(lr51)
r52 <- exp(lr52)
r53 <- exp(lr53)
r54 <- exp(lr54)
r55 <- exp(lr55)
r56 <- exp(lr56)
r57 <- exp(lr57)
r58 <- exp(lr58)
r59 <- exp(lr59)
r60 <- exp(lr60)
r61 <- exp(lr61)
r62 <- exp(lr62)
r63 <- exp(lr63)
r64 <- exp(lr64)
r65 <- exp(lr65)
r66 <- exp(lr66)
r67 <- exp(lr67)
r68 <- exp(lr68)
r69 <- exp(lr69)
r70 <- exp(lr70)
r71 <- exp(lr71)
r72 <- exp(lr72)
s <-exp(lsd)
n0 <- exp(ln0)
predN<-multi.func.p(r1=r1,r2=r2,r3=r3,r4=r4,r5=r5,r6=r6, r7=r7,r8=r8,
r9=r9, r10=r10,r11=r11, r12=r12, r13=r13, r14=r14,
r15=r15, r16=r16, r17=r17, r18=r18, r19=r19, r20=r20,
r21=r21,
r22=r22, r23=r23, r24=r24, r25=r25,r26=r26,
r27=r27, r28=r28, r29=r29, r30=r30, r31=r31, r32=r32,
r33=r33, r34=r34, r35=r35, r36=r36,
r37, r38, r39, r40, r41, r42, r43, r44, r45, r46, r47,
r48, r49, r50, r51, r52, r53, r54,
r55, r56, r57, r58, r59, r60, r61,
r62, r63, r64, r65, r66, r67, r68, r69, r70, r71, r72,
obs=obs,species.vec = species.vec, n0 = n0)
# obs2 <- obs[!is.na(obs)]
# predN2 <- predN[!is.na(obs)]
# param <- dampack::beta_params(mean = predN2, sigma = sd)
# alpha <- param[1]
# alpha <- unlist(alpha)
# beta <- param[2]
# beta <- unlist(beta)
predN[predN==0]<-.01
predN[predN==1]<-.99
# print(obs)
# print(predN)
liks<-0
for(j in 1:nrow(obs)){
lastobs <- 0
for(i in 1:ncol(obs)){
if(!is.na(obs[j, i])){
tbtwn<-i-lastobs
# print(tbtwn)
liks<-c(liks, dnorm(x=qlogis(obs[j, i]),mean=qlogis(predN[j, i]),sd=sqrt(tbtwn*s^2)))
lastobs<-i
# print(liks)
}
}
}
# likes <- dbeta(x=obs2,shape1 = alpha, shape2 = beta)
# likes <- dnorm(x=qlogis(obs2), mean=plogis(predN2), sd = sd)
nll<--1*sum(log(liks[-1]))
return(nll)
}
#test
nll.multi.func.p(lr1 = log(.4), lr2 = log(.4),lr3 = log(.4),
lr4 = log(.4),lr5 = log(.4),lr6 = log(.4),
lr7 = log(.4),lr8 = log(.4),lr9 = log(.4), lr10 = log(.4),
lr11 = log(.4), lr12 = log(.4), lr13 = log(.4), lr14 = log(.4), lr15 = log(.4),
lr16 = log(.4), lr17 = log(.4), lr18 = log(.4), lr19 = log(.4),
lr20 = log(.4), lr21 = log(.4), lr22 = log(.4), lr23 = log(.4),
lr24 = log(.4), lr25 = log(.4),lr26 = log(.4), lr27 = log(.4),
lr28 = log(.4), lr29 = log(.4), lr30 = log(.4), lr31 = log(.4),
lr32 = log(.4), lr33 = log(.4), lr34 = log(.4), lr35 = log(.4),lr36 = log(.4),
ln0 = log(.01), obs = native.mat, lsd = log(.05), species.vec = species.vec)
